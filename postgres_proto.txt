# Specification for Server-Side protocol

config {
    allow_ssl defaults to False, # TODO: `True` unimplemented at the moment
    allow_gss defaults to False, # TODO: `True` unimplemented at the moment

    subconfig TLSStream { # Imports SSL configuration from the SSL protocol design
        version defaults to [TLS_1_2, TLS_1_3],
        # ... other SSL-specific settings
    }
}

channel UpperLayer # Unnecessary, included by default
channel AssociatedClient
channel SideChannelClient # Used for instances where 

state AwaitingStartup:
    event getClientStartup(incoming_data: bytearray) from AssociatedClient ->
            (StartupReceived, StartupMessage to UpperLayer),
            (SSLWrap, bytearray to AssociatedClient),
            (AwaitingStartup), # Only occurs when SSLRequest received and `allow_ssl` is set to `False`
            (UnrecoverablePacketError, bytearray to AssociatedClient)

state GSSInitiated:

state SSLWrap:
    event wrapAssociatedClientSSL() -> (SSLInitiated) # This is a special kind of state. It can only have one event (as that event requires no input to trigger its action), and it can be triggered immediately after it has been transitioned into, though a given implementation may generate code that could do something else (such as reading input that is ready to be read from a socket) before handling this state's event

state SSLInitiated:
    event getClientStartupSSL(incoming_data: bytearray) from AssociatedClient ->
            (StartupReceived, StartupMessage to UpperLayer),
            (SSLWrap, bytearray to AssociatedClient),
            (AwaitingStartup), # Only occurs when SSLRequest received and `allow_ssl` is set to `False`
            (UnrecoverablePacketError, bytearray to AssociatedClient)

state StartupReceived:

state AuthenticationRequested:

state UnrecoverablePacketError:

# `read_data_remaining` variable is what triggers the 
# `ExcessData` or `MissingData` errors.

def event wrapAssociatedClientSSL():
    replace channel DataStream with TLSStream {
        AssociatedClient = AssociatedClient, 
        config = config.TLSStream
    }

    return SSLInitiated
}
    

def event getClientStartup(incoming_data: bytes):
    read incoming_data as input_stream:
        let message_length = Int32()
        if (message_length - 4) matches:
            Some(val) => input_stream.remaining_length = val
            None => ParseError("")

        let protocol_number = Int32()
        if protocol_number matches:
            80877103 => 
                if configuration.allow_ssl matches:
                    True => return SSLWrap, b"S",
                    False => return AwaitingStartup, b"N" # TODO: correct behavior?
            08077104 => 
                if configuration.allow_gss matches:
                    True => return GSSInitiated, b"G",
                    False => return AwaitingStartup, b"N" # TODO: correct behavior?
            196608 => 
                return StartupReceived, StartupMessage {
                    length: message_length,
                    parameters: startup_parameters(),
                }
    on ParseError | ExcessData | MissingData:
        return UnrecoverablePacketError, 

fn read startup_parameters():
    # let mut parmeters = Map<String, String>::new()
    # let parmeters = Map<String, String>::new() # NO MUT ALLOWED
    let parameters = Map()  # Also NO EXPLICIT GENERICS ALLOWED
    loop:
        let key = NullTerminatedString()
        if key matches:
            "" => return parameters
            _ => 
                let value = NullTerminatedString()
                parameters = insert(parameters, key, value) matches:
                    Some(params) => params,
                    None => return ParseError("")
	
            # if key in parameters:
            #     return ParseError("")
            # else:
            #     let value = NullTerminatedString()
            #     parameters.insert(key, value)
            # Also NO MEMBER FUNCTIONS FOR DATA TYPES

fn write startup_error():
    Bytes(b"E")

